<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GAN</title>
    <link rel="stylesheet" href="style-Deeplearning8.css">
</head>
<body>
  <div class="content-container">
    <!-- 제목 -->
      <h1 class="left"> DCGAN </h1>

    <div class="description-section">
      <h2>GAN 파생 기술</h2>
      <ul>
        <li>GAN은 생성자와 판별자가 서로 대결하면서 학습하는 구조이기 때문에 학습이 매우 불안정.</li>
        <li>생성자와 판별자 중 한쪽으로 치우친 훈련이 발생하면 성능에 문제가 생겨 정상적인 분류(진짜 혹은 가짜 분류)가 불가능.</li>
        <li>이러한 제약을 해결한 모델이 <strong>DCGAN</strong>(<em>Deep Convolutional GAN</em>).</li>
        <li>이름에서도 알 수 있듯이 DCGAN은 GAN 학습에 CNN을 사용하는 것.</li>
      </ul>

      <h2>DCGAN</h2>
      <ul>
        <li>
          DCGAN은 GAN과 동일하게 입력된 이미지를 바탕으로 그것과 매우 유사한 가짜 이미지를 만들고, 이를 평가하는 과정을 반복하여 실제와 매우 유사한 이미지를 생산하는 학습법.
        </li>
        <li>
          DCGAN 역시 생성자와 판별자 네트워크 두 개가 서로 적대적으로 학습하는 구조.
        </li>
      </ul>

      <ul>
        <li>그럼 왜 생성자 네트워크에서는 업샘플링을 사용하고, 판별자 네트워크에서는 스트라이드 합성곱을 사용할까?</li>
        <li><strong>생성자 네트워크</strong>에서는 노이즈를 입력으로 받아 훈련 데이터셋의 <strong>이미지와 같은 해상도를 가진 이미지를 생성해야 하기 때문에 공간을 확장시켜야</strong> 업샘플링이 필요.</li>
        <li>반면 <strong>판별자 네트워크</strong>는 실제 이미지와 생성자가 생성한 이미지 사이에서 어떤 이미지가 진짜인지 판단해야 하기 때문에 <strong>각 이미지의 특성을 추출할 수 있는 합성곱 연산</strong>을 수행.</li>
        <li>이때 스트라이드 합성곱을 사용하면 특성을 잘 추출할 수 있음.</li><br>
        <li>생성자가 수행하는 <strong>Deconvolution Layer</strong>는 이 때 손실된 정보를 복원하는 일을 한다.</li>
        <li><strong>Deconvolution</strong>은 여러 가지 의미로 사용되지만, 수학적으로는 정확히<strong>Convolution 연산의 역연산</strong>을 가리키는 개념이다.</li>
        <li>그렇다면 과연 프로그래밍적으로 완전한 역연산을 구현할 수 있을까?</li>
      </ul>

      <div class="image-section.left">
        <img src="Deep learning9 images/1.png" alt="1" class="deep-learning-image">
      </div>
      <ol>
        <li>
          <strong>입력 파라미터 설정:</strong>
          <ul>
            <li><code>input size = (1, 2, 3)</code> (입력 행렬 크기)</li>
            <li><code>Kernel size = 4</code> (커널 크기)</li>
            <li><code>stride = 1</code> (이동 간격)</li>
            <li><code>padding = 1</code> (경계 패딩)</li>
          </ul>
        </li>
        <li>
          <strong>출력 크기 계산:</strong>
          <ul>
            <li>
              출력 크기는 아래 공식을 사용합니다:<br>
                <img src="Deep learning9 images/2.png" alt="2">
            </li>
            <li>이 공식을 통해 출력 행(row) 크기가 5, 출력 열(column) 크기가 6임을 확인합니다.</li>
          </ul>
        </li>
        <li>
          <strong>ConvTranspose2d 연산 과정:</strong>
          <ul>
            <li><strong>Filter (kernel)</strong> 값이 주어진 상태에서 입력 행렬에 역연산이 수행됩니다.</li>
            <li>그림은 필터가 입력 값 <code>(1, 4)</code>에 적용되며 출력 값을 계산하는 과정을 시각적으로 보여줍니다.</li>
          </ul>
        </li>
      </ol>

        <div class="image-section.left">
            <img src="Deep learning9 images/3.png" alt="3" class="deep-learning-image">
        </div>
        <ol>
            <li>
                <strong>왼쪽 연산 과정:</strong>
                <ul>
                    <li>입력 행렬에서 값 <code>2</code>가 선택되어 <code>ConvTranspose2d</code> 연산이 수행됩니다.</li>
                    <li>필터(kernel)의 각 값이 입력 값 <code>2</code>와 곱해져 결과가 출력 행렬에 추가됩니다.</li>
                    <li>이 과정을 통해 출력 행렬의 특정 위치에 값이 채워지는 모습이 보입니다.</li>
                </ul>
            </li>
            <li>
                <strong>오른쪽 연산 과정:</strong>
                <ul>
                    <li>입력 행렬에서 값 <code>3</code>이 선택되어 동일한 연산이 반복됩니다.</li>
                    <li>필터(kernel)가 이동하며 값 <code>3</code>과 곱해진 결과가 출력 행렬의 다른 위치에 추가됩니다.</li>
                </ul>
            </li>
            <li>
                <strong>핵심 개념:</strong>
                <ul>
                    <li>
                        <strong>필터(kernel)</strong>은 입력 값과 곱셈 및 합산 연산을 통해 출력 행렬의 값을 생성합니다.
                    </li>
                    <li>필터가 입력 행렬 위에서 이동하며 연속적으로 연산이 수행됩니다.</li>
                </ul>
            </li>
        </ol>

        <div class="image-section.left">
            <img src="Deep learning9 images/4.png" alt="4" class="deep-learning-image">
        </div>
        <ol>
            <li>
                <strong>입력 값 6에 대한 연산:</strong>
                <ul>
                    <li>입력 행렬의 값 <code>6</code>이 선택되어 <code>ConvTranspose2d</code> 연산이 수행됩니다.</li>
                    <li>필터(kernel)의 각 값이 입력 값 <code>6</code>과 곱해져 출력 행렬의 특정 위치에 더해집니다.</li>
                </ul>
            </li>
            <li>
                <strong>필터(kernel)와 출력:</strong>
                <ul>
                    <li>필터(kernel)의 값:</li>
                    <pre>
0.1  0.2  0.3  0.4
0.5  0.6  0.7  0.8
0.9  1.0  1.1  1.2
1.3  1.4  1.5  1.6</pre>
                    <li>필터 값이 입력 값 <code>6</code>에 곱해져 각 위치에서 출력값을 생성합니다.</li>
                </ul>
            </li>
            <li>
                <strong>출력 행렬 업데이트:</strong>
                <ul>
                    <li>출력 행렬의 각 위치는 연산 결과로 업데이트되며, 이는 입력 값 <code>6</code>과 필터의 곱셈 및 합산의 결과입니다.</li>
                    <li>연산 후, 출력 행렬에는 다음과 같은 값이 추가됩니다:</li>
                    <pre>
0.6  1.2  1.8  2.4
3.0  3.6  4.2  4.8
7.8  8.4  9.0  9.6</pre>
                </ul>
            </li>
        </ol>

        <div class="image-section.left">
            <img src="Deep learning9 images/5.png" alt="5" class="deep-learning-image">
        </div>
        <p>6개의 Input 값에 대한 결과를 element-wise addition 으로 최종 결과 도출</p>
        <ol>
            <li>
                <strong>6개의 입력 값에 대한 연산 결과:</strong>
                <ul>
                    <li>각 입력 값에 대해 <code>ConvTranspose2d</code> 연산이 수행되며, 이를 통해 6개의 개별 출력 행렬이 생성됩니다.</li>
                    <li>이 행렬들은 각각 필터와 입력 값의 곱셈 결과를 나타냅니다.</li>
                </ul>
            </li>
            <li>
                <strong>Element-wise Addition:</strong>
                <ul>
                    <li>6개의 출력 행렬을 같은 위치에 있는 요소끼리 더해 최종 결과를 생성합니다.</li>
                    <li>이 과정을 통해 모든 입력 값의 연산 결과가 하나의 출력 행렬로 결합됩니다.</li>
                </ul>
            </li>
            <li>
                <strong>최종 출력 (Final Result):</strong>
                <ul>
                    <li>합산된 결과는 최종 출력 행렬로 나타나며, 이는 입력 값들이 <code>ConvTranspose2d</code>를 통해 출력 데이터로 변환된 결과입니다.</li>
                </ul>
            </li>
        </ol>

        <div class="image-section.left">
            <img src="Deep learning9 images/6.png" alt="6" class="deep-learning-image">
        </div>
        <ol>
            <li>
                <strong>Generator 구조:</strong>
                <ul>
                    <li>
                        Generator는 작은 랜덤 벡터(예: <code>fake_sz=100</code>)를 받아 이미지를 생성하는 역할을 합니다.
                    </li>
                    <li>
                        코드는 <code>nn.Sequential</code>을 사용하여 Generator의 계층을 정의합니다:
                        <ul>
                            <li>첫 번째 계층: <code>ConvTranspose2d</code>로 입력 벡터 크기를 4x4로 변환.</li>
                            <li>이후 계층: 점진적으로 해상도를 확대하며 채널 수를 줄이는 구조.</li>
                            <li>마지막 계층: 최종 이미지를 생성 (<code>tanh</code> 활성화 함수 사용).</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                <strong>ConvTranspose2d 연산:</strong>
                <ul>
                    <li>
                        <strong>입력 및 출력 크기 계산:</strong>
                        <ul>
                            <li>공식:<br>
                                    <img src="Deep learning9 images/7.png" alt="7">
                            </li>
                            <li>첫 번째 계층에서:<br>
                                <code>kernel=4, stride=1, padding=0</code> 설정.</li>
                            <li>입력 크기 <code>1x1</code> → 출력 크기 <code>4x4</code>.</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                <strong>Generator 계층의 세부 구조:</strong>
                <ul>
                    <li>
                        각 계층에서 <code>ConvTranspose2d</code>, <code>BatchNorm2d</code>, <code>ReLU</code>가 조합되어 사용됨:
                        <ul>
                            <li><code>ConvTranspose2d</code>: 이미지를 점진적으로 확장.</li>
                            <li><code>BatchNorm2d</code>: 학습을 안정화하고 성능을 향상.</li>
                            <li><code>ReLU</code>: 활성화 함수로 비선형성을 추가.</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ol>

        <div class="image-section.left">
            <img src="Deep learning9 images/8.png" alt="8" class="deep-learning-image">
        </div>
        <ol>
            <li>
                <strong>ConvTranspose2d 설정</strong>
                <ul>
                    <li><strong>파라미터:</strong>
                        <ul>
                            <li><code>kernel_size = 4</code></li>
                            <li><code>stride = 2</code></li>
                            <li><code>padding = 1</code></li>
                        </ul>
                    </li>
                    <li>입력 크기: <code>4 × 4</code> (채널 수: 512).</li>
                    <li>출력 크기: <code>8 × 8</code> (채널 수: 256).</li>
                </ul>
            </li>
            <li>
                <strong>출력 크기 계산</strong>
                <ul>
                    <li><strong>공식:</strong></li>
                    <img src="Deep learning9 images/9.png" alt="9">
                    <li>입력 크기 <code>x_in = 4</code>,</li>
                    <li><code>kernel size = 4</code>,</li>
                    <li><code>padding = 1</code>,</li>
                    <li><code>stride = 2</code>.</li>
                    <li>계산 결과:
                        <img src="Deep learning9 images/10.png" alt="10" class="deep-learning-image">
                    </li>
                </ul>
            </li>
            <li>
                <strong>Generator 계층의 역할</strong>
                <ul>
                    <li>두 번째 <code>ConvTranspose2d</code> 계층은:</li>
                    <ul>
                        <li>입력 <code>4 × 4</code> 데이터를 <code>8 × 8</code>로 확장.</li>
                        <li>채널 수를 <code>512 → 256</code>으로 감소.</li>
                    </ul>
                    <li>이 과정을 통해 Generator는 점진적으로 이미지를 확장하며 해상도를 높입니다.</li>
                </ul>
            </li>
        </ol>

        <div class="image-section.left">
            <img src="Deep learning9 images/11.png" alt="11" class="deep-learning-image">
        </div>
        <ol>
            <li>
                <strong>Padding 적용 과정:</strong>
                <ul>
                    <li>
                        <code>padding = 1</code>이 설정되면, 입력 행렬 주변에 1칸씩 0으로 채운 <strong>패딩(padding)</strong>이 추가됩니다.
                    </li>
                    <li>계산 결과는 패딩을 포함한 크기에서 시작하여 출력 크기가 결정됩니다:</li>
                    <ul>
                        <li>패딩 적용 전: <code>8 × 8</code></li>
                        <li>패딩 적용 후: <code>10 × 10</code></li>
                    </ul>
                </ul>
            </li>
            <li>
                <strong>Stride 적용 과정:</strong>
                <ul>
                    <li>
                        <code>stride = 2</code>로 설정되면, 필터(kernel)가 한 번의 연산 후 <strong>2칸씩 이동</strong>합니다.
                    </li>
                    <li>필터가 이동하면서 새로운 위치에서 출력 값을 계산하고, 이를 출력 행렬에 기록합니다.</li>
                </ul>
            </li>
            <li>
                <strong>출력 과정 시작:</strong>
                <ul>
                    <li>첫 번째 계산: 필터가 <code>4 × 4</code> 입력의 첫 번째 위치에서 연산.</li>
                    <li>두 번째 계산: 필터가 2칸 이동한 후 새로운 위치에서 연산.</li>
                </ul>
            </li>
        </ol>
        
